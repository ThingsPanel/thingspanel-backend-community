# 物联网设备当前值存储重构 - 概要设计

## 1. 背景与目标

### 1.1 当前问题
- PostgreSQL `telemetry_current_datas` 表高频UPDATE导致性能瓶颈
- 数据库锁竞争严重，响应延迟高
- 物联网高并发场景下连接池压力大

### 1.2 改造目标
- **性能提升**：使用Redis存储设备最新值，提升查询性能50%以上
- **向下兼容**：通过配置开关平滑切换，保持现有功能不变
- **架构清晰**：遵循现有目录结构最佳实践

## 2. 解决方案总览

### 2.1 核心思路
```
当前：设备数据 → PostgreSQL (历史+最新值)
改造后：设备数据 → PostgreSQL (历史) + Redis (最新值，仅当配置启用时)
```

**关键原则**：
- 配置开关控制：`device_current_value_redis_enabled`
- 明确选择：要么Redis，要么数据库，无自动降级
- 行为可预测：系统行为完全由配置决定

### 2.2 数据结构
```json
// Redis Hash: device:{device_id}:latest
{
  "temperature": "{\"ts\": 1704067200000, \"value\": 25.3}",
  "sensor_data": "{\"ts\": 1704067201000, \"value\": {\"temp\": 25.3, \"hum\": 60}}"
}
```

## 3. 配置设计

### 3.1 配置开关
在 `configs/conf.yml` 中添加：

```yaml
# Storage 存储层配置
storage:
  channel_buffer_size: 1000
  telemetry_batch_size: 500
  telemetry_flush_interval: 1000
  enable_metrics: true

  # 【新增】设备当前值Redis存储开关
  device_current_value_redis_enabled: false  # 默认false，保持兼容
```

**说明**：
- `false`: 保持原有逻辑，最新值存储在PostgreSQL
- `true`: 启用Redis存储最新值，PostgreSQL只存储历史数据

### 3.2 Redis配置复用
直接复用现有的Redis配置，无需新增：
```yaml
db:
  redis:
    addr: 127.0.0.1:6379
    db: 1
    password: "redis"
```

## 4. 目录结构与实现规划

### 4.1 最佳实践目录结构

基于 `docs/code_help/directory_structure.md` 的架构指导：

```
internal/storage/                    # 【核心实现目录】
├── interfaces.go                    # 【扩展】添加Redis相关接口
├── types.go                        # 【扩展】添加Redis数据结构
├── config.go                       # 【扩展】添加配置开关字段
├── storage.go                      # 【修改】添加数据路由逻辑
├── telemetry_writer.go             # 【保持】历史数据写入逻辑
├── direct_writer.go                # 【保持】属性/事件写入逻辑
├── redis_current_writer.go         # 【新增】Redis最新值写入器
├── redis_current_reader.go         # 【新增】Redis最新值读取器
└── redis_batch_writer.go           # 【新增】Redis批量写入优化器
```

### 4.2 职责分工

#### 4.2.1 `redis_current_writer.go` - Redis写入器
**职责**：处理设备最新值写入Redis
**位置**：`internal/storage/redis_current_writer.go`
```go
// 核心功能
- 单个指标写入Redis Hash
- 批量指标写入优化
- 数据序列化（JSON）
- 错误处理和重试
```

#### 4.2.2 `redis_current_reader.go` - Redis读取器
**职责**：从Redis查询设备最新值
**位置**：`internal/storage/redis_current_reader.go`
```go
// 核心功能
- 单个指标查询
- 批量指标查询
- 数据反序列化
- 缓存失效处理
```

#### 4.2.3 `storage.go` - 数据路由器
**职责**：根据配置决定数据流向
**位置**：`internal/storage/storage.go` (修改现有文件)
```go
// 数据路由逻辑
func (s *storage) handleTelemetryMessage(msg *Message) error {
    // 1. 始终写入历史数据到PostgreSQL
    s.telemetryWriter.write(msg)

    // 2. 根据配置决定最新值存储方式
    if s.config.DeviceCurrentValueRedisEnabled {
        return s.redisWriter.WriteCurrentValues(msg.DeviceID, convertToMetricData(msg))
    }
    // 否则使用原有PostgreSQL逻辑
    return nil
}
```

### 4.3 接口扩展

#### 4.3.1 `interfaces.go` 扩展
```go
// 【新增】Redis最新值写入接口
type CurrentValueWriter interface {
    WriteCurrentValue(ctx context.Context, deviceID, metric string, ts int64, value interface{}) error
    WriteCurrentValues(ctx context.Context, deviceID string, values map[string]MetricData) error
}

// 【新增】Redis最新值读取接口
type CurrentValueReader interface {
    GetDeviceMetric(ctx context.Context, deviceID, metric string) (*MetricData, error)
    GetDeviceLatestData(ctx context.Context, deviceID string) (map[string]*MetricData, error)
}
```

#### 4.3.2 `types.go` 扩展
```go
// 【新增】Redis存储的数据结构
type MetricData struct {
    Ts    int64       `json:"ts"`
    Value interface{} `json:"value"`
}
```

#### 4.3.3 `config.go` 扩展
```go
type Config struct {
    // 现有配置保持不变...
    ChannelBufferSize     int `yaml:"channel_buffer_size"`
    TelemetryBatchSize    int `yaml:"telemetry_batch_size"`
    TelemetryFlushInterval int `yaml:"telemetry_flush_interval"`
    EnableMetrics         bool `yaml:"enable_metrics"`

    // 【新增】Redis存储开关
    DeviceCurrentValueRedisEnabled bool `yaml:"device_current_value_redis_enabled"`
}
```

## 5. Service层查询改动评估

### 5.1 查询接口影响分析

#### 5.1.1 当前查询接口
```go
// DAL层接口 (internal/dal/telemetry_current_datas.go)
GetCurrentTelemetryDataEvolution(deviceId string) ([]*model.TelemetryCurrentData, error)
GetCurrentTelemetryDataEvolutionByKeys(deviceId string, keys []string) ([]*model.TelemetryCurrentData, error)
```

#### 5.1.2 Service层使用点统计
| 文件 | 使用次数 | 主要业务场景 |
|------|---------|-------------|
| `internal/service/device.go` | 4处 | 设备详情、自动化规则、看板显示 |
| `internal/service/telemetry_data.go` | 5处 | WebSocket推送、API查询、数据格式化 |

**总计：9处调用点需要改造**

#### 5.1.3 数据结构对比
```go
// 当前：PostgreSQL结构 (分离存储)
type TelemetryCurrentData struct {
    DeviceID string    `gorm:"column:device_id"`
    Key      string    `gorm:"column:key"`
    TS       time.Time `gorm:"column:ts"`
    BoolV    *bool     `gorm:"column:bool_v"`
    NumberV  *float64  `gorm:"column:number_v"`
    StringV  *string   `gorm:"column:string_v"`
    TenantID string    `gorm:"column:tenant_id"`
}

// 改造后：Redis结构 (JSON统一存储)
type MetricData struct {
    Ts    int64       `json:"ts"`
    Value interface{} `json:"value"`
}
```

### 5.2 查询逻辑改造方案

#### 5.2.1 数据转换适配器设计

**设计原则**：配置驱动，无自动降级
- `device_current_value_redis_enabled: true` → 只从Redis查询
- `device_current_value_redis_enabled: false` → 只从数据库查询
- 无Redis失败时的自动降级逻辑，行为完全可预测

```go
// internal/service/telemetry_adapter.go 【新增】
type TelemetryAdapter struct {
    redisReader CurrentValueReader
    dbReader     interface{} // 原有DAL接口
    config       *Config
}

// 统一查询接口：根据配置选择数据源，无降级逻辑
func (a *TelemetryAdapter) GetCurrentTelemetryData(deviceID string) ([]*model.TelemetryCurrentData, error) {
    if a.config.DeviceCurrentValueRedisEnabled {
        // 从Redis查询并转换格式
        redisData, err := a.redisReader.GetDeviceLatestData(context.Background(), deviceID)
        if err != nil {
            return nil, fmt.Errorf("redis query failed: %w", err)
        }
        return a.convertRedisToModel(redisData, deviceID), nil
    }

    // 从数据库查询 (原有逻辑)
    return a.dbReader.GetCurrentTelemetryDataEvolution(deviceID)
}
```

#### 5.2.2 数据格式转换实现
```go
func (a *TelemetryAdapter) convertRedisToModel(redisData map[string]*MetricData, deviceID string) []*model.TelemetryCurrentData {
    result := make([]*model.TelemetryCurrentData, 0, len(redisData))

    for key, metricData := range redisData {
        item := &model.TelemetryCurrentData{
            DeviceID: deviceID,
            Key:      key,
            TS:       time.UnixMilli(metricData.Ts),
            // 根据value类型设置对应字段
        }

        switch v := metricData.Value.(type) {
        case bool:
            item.BoolV = &v
        case float64:
            item.NumberV = &v
        case string:
            item.StringV = &v
        // 复杂对象序列化为JSON字符串
        default:
            jsonBytes, _ := json.Marshal(v)
            str := string(jsonBytes)
            item.StringV = &str
        }

        result = append(result, item)
    }

    return result
}
```

### 5.3 实施步骤

#### 5.3.1 阶段一：基础设施 (2-3天)
- [ ] 在 `config.go` 添加配置开关字段
- [ ] 在 `configs/conf.yml` 添加配置项
- [ ] 创建Redis写入器和读取器的基础结构

#### 5.3.2 阶段二：核心功能 (4-6天)
- [ ] 实现 `redis_current_writer.go`
- [ ] 实现 `redis_current_reader.go`
- [ ] 实现 `telemetry_adapter.go` 数据转换适配器
- [ ] 修改 `storage.go` 添加路由逻辑

#### 5.3.3 阶段三：兼容性改造 (3-4天)
- [ ] 修改9处Service层调用点，注入适配器
- [ ] 数据格式转换逻辑验证
- [ ] 向下兼容性测试

#### 5.3.4 阶段四：测试验证 (2-3天)
- [ ] 单元测试覆盖 (包括转换逻辑)
- [ ] 数据一致性验证 (Redis vs DB)
- [ ] Service层功能回归测试
- [ ] 性能基准测试对比

#### 5.3.5 阶段五：灰度上线 (1-2天)
- [ ] 按租户维度逐步启用
- [ ] 监控告警配置
- [ ] 回滚方案准备

## 6. 性能预期

### 6.1 写入性能
- **当前**：PostgreSQL UPDATE ~50-100ms
- **改造后**：Redis HSET ~1-5ms
- **提升**：10-50倍性能提升

### 6.2 查询性能
- **当前**：PostgreSQL SELECT ~20-50ms
- **改造后**：Redis HGET ~0.5-2ms + 数据转换 ~1-2ms
- **提升**：10-50倍性能提升 (转换开销可接受)

### 6.3 Service层兼容性
- **数据转换开销**：<2ms (JSON解析+格式转换)
- **内存使用**：Redis数据转换后格式与原有保持一致
- **错误处理**：Redis失败自动降级到数据库，保证高可用

### 6.4 并发能力
- 支持10,000+并发设备数据更新
- Redis内存使用量与设备指标数量正相关
- 连接池复用减少资源开销

## 7. 监控与运维

### 7.1 关键指标
- Redis写入成功率/QPS
- Redis内存使用量
- 数据一致性检查结果
- 配置开关切换成功率

### 7.2 告警规则
- Redis连接失败
- 内存使用率超80%
- 数据不一致率超1%

## 8. 风险控制

### 8.1 技术风险
- **Redis故障**：配置开关控制，无自动降级；可手动切换到PostgreSQL
- **数据丢失**：写入时同时写入Redis和DB，确保数据安全
- **内存溢出**：设置合理的过期策略，定期清理离线设备数据

### 8.2 业务风险
- **功能兼容**：保持现有API接口不变
- **数据一致**：历史数据完整性不受影响
- **性能波动**：灰度发布逐步验证

## 7. 验收标准

### 7.1 功能验收
- [ ] 配置开关正确控制存储策略
- [ ] Redis和数据库数据保持一致
- [ ] 查询接口返回正确数据格式
- [ ] Service层9处调用点正确适配

### 7.2 兼容性验收
- [ ] 数据格式转换正确 (Redis→Model)
- [ ] 复杂对象序列化/反序列化正常
- [ ] 配置开关正确控制查询数据源 (Redis或DB，无降级)
- [ ] 现有API接口行为保持不变

### 7.3 性能验收
- [ ] 写入性能提升10倍以上
- [ ] 查询响应时间<5ms (p95)
- [ ] 数据转换开销<2ms
- [ ] 支持10,000+并发设备

### 7.4 稳定性验收
- [ ] 系统可用性>99.9%
- [ ] 数据丢失率<0.01%
- [ ] Service层功能回归通过
- [ ] 故障恢复时间<5分钟

---

**文档版本**: v3.0
**最后更新**: 2024-12-31
**基于目录结构**: `docs/code_help/directory_structure.md`
**配置文件**: `configs/conf.yml`
**影响范围**: 9处Service层调用点