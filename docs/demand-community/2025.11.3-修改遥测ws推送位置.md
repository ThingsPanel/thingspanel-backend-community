# 修改遥测 WebSocket 推送位置

## 需求描述

将遥测数据的 WebSocket 推送从 Uplink 层移动到 Storage 层，确保只有在数据成功存储后才进行推送。

## 修改位置

### 原位置
`internal/uplink/telemetry.go` → `processDirectDeviceMessage()` 方法

```go
// 4. 发送到 Storage（同步发送到 channel）
f.storageInput <- &storage.Message{...}

// 5. WebSocket 实时推送（异步）❌ 需要移除
go f.checkAndPublishToWS(device.ID, device.TenantID, triggerValues)
```

### 新位置
`internal/storage/storage.go` → `handleMessage()` 方法

```go
func (s *storage) handleMessage(msg *Message) {
    switch msg.DataType {
    case DataTypeTelemetry:
        s.metrics.incTelemetryReceived()
        
        // 1. 写入数据库
        if err := s.telemetryWriter.write(msg); err != nil {
            s.logger.Errorf("handle telemetry message failed: %v", err)
            return // 存储失败，不推送
        }
        
        // 2. WebSocket 推送（新增，异步执行）
        go s.publishToWebSocket(msg)
    
    // ... 其他数据类型
    }
}
```

## 实现步骤

1. **在 Storage 层添加 WebSocket 推送方法**
   - 从 `msg.Data` 中提取遥测数据并转换为 `map[string]interface{}` 格式
   - 复用 Uplink 层的推送逻辑（检查订阅、发布到 Redis）

2. **移除 Uplink 层的推送调用**
   - 删除 `internal/uplink/telemetry.go` 中第 337 行的推送代码

3. **数据转换**
   - `Message.Data` 类型为 `[]TelemetryDataPoint`
   - 需要转换为 `map[string]interface{}` 格式用于推送

## 优势

- ✅ **数据一致性**：只有存储成功的数据才会推送
- ✅ **逻辑集中**：所有存储后的处理都在 Storage 层
- ✅ **错误隔离**：存储失败不会触发推送

## 注意事项

- WebSocket 推送保持异步执行，不阻塞存储流程
- 需要确保数据格式转换正确（TelemetryDataPoint → map）
- 保留原有的订阅检查逻辑（Redis EXISTS 检查）
