# 物联网设备当前值存储重构

## 背景

当前系统使用关系型数据库表 telemetry_current_datas 存储设备当前值。在物联网高并发、高频更新场景下，数据库面临以下问题：

- 频繁的 UPDATE 操作导致大量锁竞争
- 磁盘 I/O 成为性能瓶颈
- 数据库连接池压力大
- 响应延迟高，影响实时性

需要引入 Redis 作为设备当前值的存储方案，提升写入性能和查询响应速度。

## 1. 核心需求

- **只存最新值**：每个设备只保存各项指标的最后上报值
- **永久保存**：数据不过期，保留设备最后已知状态
- **分次上报**：设备可多次上报不同指标，自动合并，互不覆盖
- **时间戳记录**：保留每个指标的上报时间戳，用于展示和追踪
- **任意数据类型**：value支持任意类型，包括对象、数组、基本类型
- **并发安全**：多个指标同时更新互不影响
- **简单直接**：每次上报直接覆盖，无需复杂的时间戳比较逻辑

## 2. 存储方案

### 数据结构
```
类型：Redis Hash
Key：device:{device_id}:latest
字段格式：{metric_name}: JSON字符串 {"ts": timestamp, "value": metric_value}
```

### 存储示例
```
Key: device:device001:latest

Hash:
{
  "temperature": "{\"ts\": 1704067200000, \"value\": 25.3}",           // 简单浮点数
  "aqi": "{\"ts\": 1704067201000, \"value\": 149}",                   // 简单整数
  "status": "{\"ts\": 1704067202000, \"value\": \"online\"}",          // 字符串
  "alarm": "{\"ts\": 1704067203000, \"value\": true}",                // 布尔
  "sensor_data": "{\"ts\": 1704067205000, \"value\": {\"temp\": 25.3, \"hum\": 60, \"co2\": 450}}",  // JSON对象
  "array_data": "{\"ts\": 1704067206000, \"value\": [1, 2, 3, 4, 5]}" // 数组
}
```

## 3. 上报行为

```go
// 定义数据结构
type MetricData struct {
    Ts    int64       `json:"ts"`
    Value interface{} `json:"value"`
}

// 简单类型上报
tempData := MetricData{Ts: 1704067200000, Value: 25.3}
tempJson, _ := json.Marshal(tempData)
redisClient.HSet(ctx, "device:device001:latest", "temperature", string(tempJson))

// 复杂对象上报
sensorData := map[string]interface{}{
    "temp": 25.3,
    "hum":  60,
    "co2":  450,
}
sensorMetric := MetricData{Ts: 1704067205000, Value: sensorData}
sensorJson, _ := json.Marshal(sensorMetric)
redisClient.HSet(ctx, "device:device001:latest", "sensor_data", string(sensorJson))

// 数组类型上报
arrayData := []int{1, 2, 3, 4, 5}
arrayMetric := MetricData{Ts: 1704067206000, Value: arrayData}
arrayJson, _ := json.Marshal(arrayMetric)
redisClient.HSet(ctx, "device:device001:latest", "array_data", string(arrayJson))
```

## 4. 查询返回格式

```json
[
  {
    "key": "temperature",
    "ts": "2024-12-30 17:01:01.156 +0800",
    "value": 25.3
  },
  {
    "key": "sensor_data",
    "ts": "2024-12-30 17:01:05.000 +0800",
    "value": {
      "temp": 25.3,
      "hum": 60,
      "co2": 450
    }
  },
  {
    "key": "array_data",
    "ts": "2024-12-30 17:01:06.000 +0800",
    "value": [1, 2, 3, 4, 5]
  }
]
```

### Go 查询示例

```go
// 查询设备最新数据 - 支持任意类型value
func GetDeviceLatestData(ctx context.Context, deviceID string) ([]map[string]interface{}, error) {
    key := fmt.Sprintf("device:%s:latest", deviceID)

    // 获取所有字段
    data, err := redisClient.HGetAll(ctx, key).Result()
    if err != nil {
        return nil, err
    }

    var result []map[string]interface{}
    for metric, jsonStr := range data {
        var metricData MetricData
        if err := json.Unmarshal([]byte(jsonStr), &metricData); err != nil {
            continue // 跳过解析失败的数据
        }

        // value保持原始类型：可能是int, float64, string, bool, map, []interface{}等
        result = append(result, map[string]interface{}{
            "key":   metric,
            "ts":    time.UnixMilli(metricData.Ts).Format("2006-01-02 15:04:05.000 -0700"),
            "value": metricData.Value, // 直接返回，保持原始类型
        })
    }

    return result, nil
}
```

### 类型保持 - "是什么存什么"
| Go输入类型 | JSON存储 | Go读取类型 |
|----------|---------|-----------|
| `25.3` (float64) | `{"value": 25.3}` | `float64` |
| `149` (int) | `{"value": 149}` | `float64` * |
| `"online"` (string) | `{"value": "online"}` | `string` |
| `true` (bool) | `{"value": true}` | `bool` |
| `map[string]interface{}{"temp":25.3}` | `{"value": {"temp":25.3}}` | `map[string]interface{}` |
| `[]int{1,2,3}` | `{"value": [1,2,3]}` | `[]interface{}` |

*注：JSON unmarshal默认将数字解析为float64，可根据业务需要转换

## 5. 简单直接的实现方案

### 5.1 设计原则
- **直接覆盖**：每次上报直接更新，无需比较历史数据
- **简单优先**：用最少的代码实现核心功能
- **性能至上**：Redis Hash的原生性能，无额外开销

### 5.2 Go语言实现

```go
// 批量更新多个指标
func UpdateDeviceMetrics(ctx context.Context, deviceID string, metrics map[string]interface{}) error {
    key := fmt.Sprintf("device:%s:latest", deviceID)

    // 准备批量更新数据
    values := make(map[string]string)
    for metric, value := range metrics {
        data := MetricData{Value: value}
        jsonBytes, _ := json.Marshal(data)
        values[metric] = string(jsonBytes)
    }

    return redisClient.HMSet(ctx, key, values).Err()
}
```

### 5.3 并发安全
- Redis Hash天然支持字段级并发更新
- 不同指标的更新互不阻塞
- 无需复杂的锁机制或Lua脚本

### 5.3 设备长期离线
```
设备最后上报：2022-01-01
当前时间：2025-12-30

行为：保持 2022-01-01 的数据不变
说明：无过期时间，永久保存最后状态
```

## 6. 技术要点

- **存储**：Redis Hash
- **Key格式**：`device:{device_id}:latest`
- **字段格式**：`{metric_name}: {"ts": timestamp, "value": value}` (JSON字符串)
- **更新机制**：直接HSET覆盖，无需比较历史数据
- **过期策略**：不设置 EXPIRE
- **类型处理**：支持任意Go数据类型，存什么读什么
- **Go集成**：使用 encoding/json 包进行数据编解码
- **优势**：代码极简、性能最优、无额外复杂性

## 6. Go 语言实现优势

### 6.1 极简代码
```go
// 包含时间戳的数据结构
type MetricData struct {
    Ts    int64       `json:"ts"`
    Value interface{} `json:"value"`
}

func UpdateMetric(ctx context.Context, deviceID, metric string, ts int64, value interface{}) error {
    key := fmt.Sprintf("device:%s:latest", deviceID)
    data := MetricData{Ts: ts, Value: value}
    jsonBytes, _ := json.Marshal(data)
    return redisClient.HSet(ctx, key, metric, string(jsonBytes)).Err()
}
```

### 6.2 任意类型支持
- **基本类型**：`int`, `float64`, `string`, `bool`
- **复杂对象**：`map[string]interface{}`, `[]interface{}`
- **嵌套结构**：任意层级的JSON对象和数组
- **类型保持**：存什么读什么，无类型丢失

### 6.3 并发安全
- Redis Hash天然支持并发更新
- 不同指标互不阻塞，无需锁


