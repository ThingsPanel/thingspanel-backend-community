# ================================================================================================
# ThingsPanel 后端社区版 - 自动构建与发布工作流
# ================================================================================================
# 
# 【工作流功能说明】
# 本工作流用于自动化构建和发布 ThingsPanel 后端社区版，主要功能包括：
# 
# 1. 🔧 多平台交叉编译：
#    - Windows (amd64)
#    - Linux (amd64, arm64, arm v7, 386)  
#    - macOS (amd64, arm64)
# 
# 2. 📦 自动打包：
#    - Windows 平台打包为 .zip 格式
#    - 其他平台打包为 .tar.gz 格式
#    - 包含必要的配置文件和资源文件
# 
# 3. 🚀 GitHub Release 管理：
#    - 自动创建/更新 Release
#    - 上传所有平台的构建产物
#    - 支持手动指定版本标签
# 
# 【触发条件】
# - 推送到 main 分支：自动创建 'latest' 标签的发布版本
# - 手动触发：可以指定自定义标签名称
# 
# 【构建产物】
# 每个平台会生成一个包含以下内容的压缩包：
# - thingspanel-backend-community 可执行文件
# - configs/ 配置文件目录
# - sql/ 数据库脚本目录  
# - files/ 资源文件目录
# ================================================================================================

name: Build and Release

# 工作流触发条件
on:
  push:
    branches: [ "main" ]  # 当推送到 main 分支时触发
  workflow_dispatch:      # 支持手动触发
    inputs:
      tag:
        description: 'Tag name'    # 手动触发时可以指定标签名
        required: false
        default: 'latest'

jobs:
  build:
    runs-on: ubuntu-latest  # 使用 Ubuntu 最新版本作为构建环境
    steps:
    
    # 步骤1: 检出代码仓库
    - name: Checkout repository
      uses: actions/checkout@v3
    
    # 步骤2: 设置 Go 开发环境
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'  # 使用 Go 1.23 版本
    
    # 步骤3: 确定发布标签
    # 如果是推送触发则使用 'latest'，手动触发则使用用户输入的标签
    - name: Determine Release Tag
      id: determine-tag
      run: echo "RELEASE_TAG=$(if [ '${{ github.event_name }}' == 'push' ]; then echo 'latest'; else echo '${{ github.event.inputs.tag }}'; fi)" >> $GITHUB_ENV
    
    # 步骤4: 删除已存在的同名发布版本和 Git 标签
    # 避免标签冲突，如果已存在相同标签的 Release 和 Git 标签则先删除
    - name: Delete existing release and git tag if they exist
      id: delete_release
      run: |
        tag=${{ github.event.inputs.tag || 'latest' }}
        
        # 删除已存在的 GitHub Release
        release_id=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/releases/tags/$tag" | \
          jq -r '.id')
        if [ "$release_id" != "null" ]; then
          echo "Deleting existing release with ID $release_id"
          curl -s -X DELETE -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/$release_id"
        else
          echo "No existing release found for tag $tag"
        fi
        
        # 删除已存在的 Git 标签（通过 GitHub API）
        echo "Deleting existing git tag $tag if it exists"
        curl -X DELETE \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/git/refs/tags/$tag" \
          2>/dev/null || echo "Remote tag $tag does not exist"
        
    # 步骤5: 创建新的 Git 标签
    # 确保标签指向最新的提交，并且时间戳是最新的
    - name: Create new git tag
      run: |
        tag=${{ github.event.inputs.tag || 'latest' }}
        echo "Creating new git tag: $tag"
        
        # 通过 GitHub API 创建 Git 标签，避免需要配置 Git 身份
        curl -X POST \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/git/refs" \
          -d "{\"ref\":\"refs/tags/$tag\",\"sha\":\"${{ github.sha }}\"}"
        
        echo "Git tag $tag created successfully"
        
    # 步骤6: 创建新的 GitHub Release
    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
          tag_name: ${{ github.event.inputs.tag || 'latest' }}           # 使用指定的标签名
          release_name: Release ${{ github.event.inputs.tag || 'latest' }} # Release 标题
          body: Release created by GitHub Actions. Tag ${{ github.event.inputs.tag || 'latest' }}  # Release 描述
          draft: false      # 不是草稿，直接发布
          prerelease: false # 不是预发布版本
    
    # 步骤7: 多平台交叉编译和打包
    # 这是整个工作流的核心步骤，为多个目标平台构建二进制文件
    - name: Build and package for multiple platforms
      run: |
        # 定义要构建的目标平台列表
        # 格式: "操作系统/架构/ARM版本" (ARM版本是可选的)
        platforms=(
          "windows/amd64"   # Windows 64位
          "linux/amd64"     # Linux 64位
          "linux/arm64"     # Linux ARM64 (Apple M系列芯片等)
          "linux/arm/7"     # Linux ARMv7 (树莓派等嵌入式设备)
          "linux/386"       # Linux 32位
          "darwin/amd64"    # macOS Intel 芯片
          "darwin/arm64"    # macOS Apple 芯片 (M1/M2等)
        )
        
        # 遍历每个目标平台进行构建
        for platform in "${platforms[@]}"; do
          # 解析平台字符串，分别提取操作系统、架构和ARM版本
          IFS="/" read -r os arch arm_version <<< "$platform"
          
          # 设置 Go 交叉编译的环境变量
          export GOOS=$os        # 目标操作系统
          export GOARCH=$arch    # 目标架构
          export CGO_ENABLED=0   # 禁用 CGO，确保静态链接
          
          # 如果是 ARM 平台，设置 GOARM 版本
          if [ ! -z "$arm_version" ]; then
            export GOARM=$arm_version
            platform_suffix="$os-$arch-v$arm_version"  # 平台后缀包含ARM版本
          else
            unset GOARM
            platform_suffix="$os-$arch"                # 普通平台后缀
          fi
          
          echo "Building for $GOOS/$GOARCH${GOARM:+/v$GOARM}..."
          
          # 为当前平台创建输出目录
          mkdir -p "dist/$platform_suffix"
          
          # 复制必要的配置文件和资源文件到输出目录
          cp -r configs "dist/$platform_suffix/" 2>/dev/null || echo "No configs directory found"
          cp -r sql "dist/$platform_suffix/" 2>/dev/null || echo "No sql directory found"
          cp -r files "dist/$platform_suffix/" 2>/dev/null || echo "No files directory found"
          
          # 根据目标操作系统确定可执行文件名（Windows需要.exe后缀）
          if [ "$os" == "windows" ]; then
             output_file="dist/$platform_suffix/thingspanel-backend-community.exe"
          else
             output_file="dist/$platform_suffix/thingspanel-backend-community"
          fi
          
          # 执行 Go 构建命令
          go build -o "$output_file"
          
          # 检查构建是否成功
          if [ $? -ne 0 ]; then
            echo "Failed to build for $GOOS/$GOARCH${GOARM:+/v$GOARM}, skipping..."
            rm -rf "dist/$platform_suffix"  # 构建失败则删除目录
            continue
          fi
          
          # 根据平台类型创建不同格式的压缩包
          if [ "$os" == "windows" ]; then
            archive_name="thingspanel-backend-community-$platform_suffix.zip"
            # Windows 平台打包为 ZIP 格式
            (cd dist && zip -r "../$archive_name" "$platform_suffix")
          else
            archive_name="thingspanel-backend-community-$platform_suffix.tar.gz"
            # 其他平台打包为 tar.gz 格式
            tar -czf "$archive_name" -C dist "$platform_suffix"
          fi
          
          echo "Created archive: $archive_name"
        done
        
        # 列出所有创建的压缩包文件
        ls -la *.tar.gz *.zip 2>/dev/null || echo "No archives created"
    
    # 步骤8: 上传构建产物到 GitHub Release
    # 将所有平台的压缩包上传为 Release 的附件
    - name: Upload Release Assets
      id: upload-release-assets
      run: |
        # 遍历所有生成的压缩包文件
        for asset in ./thingspanel-backend-community-*.tar.gz ./thingspanel-backend-community-*.zip; do
          if [ -f "$asset" ]; then
            asset_name=$(basename "$asset")
            echo "Uploading $asset_name..."
            
            # 根据文件类型设置正确的 Content-Type
            content_type="application/gzip"
            if [[ "$asset" == *.zip ]]; then
              content_type="application/zip"
            fi
            
            # 通过 GitHub API 上传文件到 Release
            curl -XPOST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: $content_type" \
              --data-binary "@$asset" \
              "https://uploads.github.com/repos/${{ github.repository }}/releases/${{ steps.create_release.outputs.id }}/assets?name=$asset_name"
          fi
        done
    
    # 步骤9: 触发 Docker 镜像构建工作流
    # 在完成 Release 创建后，自动触发 Docker 镜像构建
    - name: Trigger Docker Image Build
      run: |
        tag=${{ github.event.inputs.tag || 'latest' }}
        echo "Triggering docker-image-build.yml workflow for tag: $tag"
        
        # 通过 GitHub API 触发 docker-image-build.yml 工作流
        curl -X POST \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/actions/workflows/docker-image-build.yml/dispatches" \
          -d '{"ref":"main"}'
        
        echo "Docker image build workflow triggered successfully"
